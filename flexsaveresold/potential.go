package flexsaveresold

import (
	"context"
	"errors"
	"fmt"
	"math"
	"sort"
	"strconv"
	"strings"
	"time"

	"cloud.google.com/go/cloudtasks/apiv2/cloudtaskspb"
	"cloud.google.com/go/firestore"

	"github.com/doitintl/hello/scheduled-tasks/amazonwebservices"
	"github.com/doitintl/hello/scheduled-tasks/amazonwebservices/mpa/accounts/dal"
	"github.com/doitintl/hello/scheduled-tasks/amazonwebservices/mpa/accounts/domain"
	"github.com/doitintl/hello/scheduled-tasks/cloudhealth"
	"github.com/doitintl/hello/scheduled-tasks/common"
	"github.com/doitintl/hello/scheduled-tasks/flexsaveresold/internal/aws_usage"
	"github.com/doitintl/hello/scheduled-tasks/slice"
)

// Potential Representation of stable EC2 workloads (aka potential) that is applicable for Flexsave for a given customer.
type Potential struct {
	Customer  *firestore.DocumentRef   `firestore:"customer"`
	Data      []map[string]interface{} `firestore:"data"`
	Timestamp time.Time                `firestore:"timestamp,serverTimestamp"`
	Disabled  bool                     `firestore:"disabled"`
}

// FanoutImportPotential This is a fanout method for importing potential
// used by Flexsave for AWS.
func (s *Service) FanoutImportPotential(ctx context.Context) error {
	log := s.Logger(ctx)
	fs := s.Firestore(ctx)

	docSnaps, err := fs.Collection("integrations").
		Doc("cloudhealth").
		Collection("cloudhealthCustomers").
		Where("disabled", "==", false).
		Documents(ctx).GetAll()
	if err != nil {
		log.Errorf("could not fetch cloudhealthCustomers documents, error: %v", err)
		return err
	}

	for _, customerSnap := range docSnaps {
		config := common.CloudTaskConfig{
			Method: cloudtaskspb.HttpMethod_GET,
			Path:   fmt.Sprintf("/tasks/flex-ri/import-potential/customer/%s", fmt.Sprint(customerSnap.Ref.ID)),
			Queue:  common.TaskQueueFlexsaveAWSPotential,
		}

		_, err = common.CreateCloudTask(ctx, &config)
		if err != nil {
			log.Errorf("failed to create job for customer: %v, error: %v", customerSnap.Ref.ID, err)
		}
	}

	return nil
}

// ImportPotentialForCustomer Import information about EC2 instance usage from CloudHealth.
//
// We call this potential as it is the baseline for recommendations and savings for a customer.
// Potential is generated by calling CloudHealth Instance Usage report and retrieving minimum
// stable workload for each instance type.
// This data is used by both Recommendations as well as UI for making new orders.
//
// Potential data can be found under /integrations/cloudhealth/cloudhealthinstances/CHTID
func (s *Service) ImportPotentialForCustomer(ctx context.Context, customerID string) error {
	log := s.Logger(ctx)
	fs := s.Firestore(ctx)

	payerAccounts, err := dal.GetMasterPayerAccounts(ctx, fs)
	if err != nil {
		return err
	}

	customerSnap, err := fs.Collection("integrations").Doc("cloudhealth").Collection("cloudhealthCustomers").Doc(customerID).Get(ctx)
	if err != nil {
		return err
	}

	var customer aws_usage.Cht
	if err := customerSnap.DataTo(&customer); err != nil {
		return err
	}

	if customer.Disabled {
		return errors.New(fmt.Sprintf("cht customer was disabled %v", customerID))
	}

	assetsDoc, err := fs.Collection("assets").Where("customer", "==", customer.Customer).Where("type", "==", common.Assets.AmazonWebServices).Documents(ctx).GetAll()
	if err != nil {
		return err
	}

	data := make([]map[string]interface{}, 0)

	for _, docSnap := range assetsDoc {
		var asset amazonwebservices.Asset
		if err := docSnap.DataTo(&asset); err != nil {
			continue
		}

		accountID := asset.Properties.AccountID

		// If no organization, they are not under any of our payers
		if asset.Properties.OrganizationInfo == nil {
			continue
		}

		payerAccountID := asset.Properties.OrganizationInfo.PayerAccount.AccountID
		// Customer can have AWS accounts under both supported, and unsupported payer.
		// Filter results to only accounts that we support for Flexsave.
		// This will make sure we don't show recommendations for accounts we can't handle.
		if !payerAccounts.IsFlexsaveAllowed(payerAccountID) {
			continue
		}

		mpa, ok := payerAccounts.Accounts[payerAccountID]
		if !ok || mpa == nil {
			log.Warningf("could not find payerAccount %v for customer %v for account %v", payerAccountID, customer.ID, accountID)
			continue
		}

		regions := getSupportedRegions(mpa)

		report, err := customerOnDemandInstancesReport(ctx, customer.ID, accountID, regions)
		if err != nil {
			if err.Error() != cloudhealth.ErrEmptyReportMessage {
				log.Warningf("could not retrieve cht data for customer %v for account %v. error: %v", customer.ID, accountID, err)
			}

			continue
		}

		var regionsTotal float64
		// We will use last 7 days excluding cloudHealthUsageDataDelay. i.e. on 28th it will use inclusive 21st to (28th - chtUsageDataDelay-1).
		nowWithOffset := time.Now().UTC().Add(cloudHealthUsageDataDelay)
		usageDelayThreshold := time.Date(nowWithOffset.Year(), nowWithOffset.Month(), nowWithOffset.Day(), 0, 0, 0, 0, time.UTC)

		for i, regionDim := range report.Dimensions[0].AWSRegions[1:] {
			for j, ec2InstanceTypeDim := range report.Dimensions[1].EC2InstanceTypes[1:] {
				for z, ec2OperatingSystemDim := range report.Dimensions[2].EC2OperatingSystems[1:] {
					minNumOfInstances := 99990.0
					usage := make(sort.Float64Slice, 0, 60) // we get 60 data points - 5 days x 12 windows

					for hourUnit, timeDim := range report.Dimensions[3].Time[1:] {
						layout := "2006-01-02 15:04"

						timeDimDate, err := time.Parse(layout, timeDim.Label)
						if err != nil {
							continue
						}

						if timeDimDate.Before(usageDelayThreshold) {
							instanceNumber := report.Data[i+1][j+1][z+1][hourUnit+1][0]
							usage = append(usage, instanceNumber)

							if minNumOfInstances > instanceNumber {
								minNumOfInstances = instanceNumber
							}
						}
					}

					// We need to find minimal viable usage for this instance that we want to cover.
					// Simply taking minimum can cause an otherwise good instance to be completely discarded
					// if it was shut down for even an hour during our block.
					// For now, as a simple measure, sort usage and skip the first X to find a sensible potential.
					sort.Sort(usage)
					index := int(float64(len(usage)) * discardedUsagePercentile)
					acceptablePotentialInstances := usage[index]

					// keep while testing, should never happen unless cosmic rays manipulate our memory
					if acceptablePotentialInstances < minNumOfInstances {
						log.Errorf("new potential lower than old: %v vs %v for %v in %v for account %v", acceptablePotentialInstances, minNumOfInstances, ec2InstanceTypeDim.Name, regionDim.Label, accountID)
					}

					if acceptablePotentialInstances > 0 {
						data = append(data, map[string]interface{}{
							"region": map[string]interface{}{
								"value":    regionDim.Name,
								"location": regionDim.Label,
							},
							"instanceType": ec2InstanceTypeDim.Name,
							"operatingSystem": map[string]interface{}{
								"value": ec2OperatingSystemDim.Name,
								"label": ec2OperatingSystemDim.Label,
							},
							"numInstances": int64(math.Floor(acceptablePotentialInstances)),
							"account":      accountID,
						})

						if !slice.Contains(domain.SharedMasterPayerAccountRegions, regionDim.Name) {
							var pricing, err = s.GetEC2Pricing(ctx, &GetPricingRequest{
								Region:          regionDim.Name,
								InstanceType:    ec2InstanceTypeDim.Name,
								OperatingSystem: ec2OperatingSystemDim.Name,
							})

							if err != nil {
								log.Errorf("error getting pricing for %v in %v for %v in account %v: err: %v", ec2InstanceTypeDim.Name, regionDim.Name, ec2OperatingSystemDim.Name, accountID, err.Error())
								continue
							}

							regionsTotal += *pricing.OnDemand * acceptablePotentialInstances
						}
					}
				}
			}
		}

		if regionsTotal > 2000 {
			log.Warningf("total instance cost for not supported regions is %v", regionsTotal)
		}
	}

	log.Infof("potential size - %v", len(data))

	instancesRef := fs.Collection("integrations").Doc("cloudhealth").Collection("cloudhealthInstances").Doc(strconv.FormatInt(customer.ID, 10))
	_, err = instancesRef.Set(ctx, Potential{
		Data:     data,
		Customer: customer.Customer,
		Disabled: false,
	})

	return err
}

func customerOnDemandInstancesReport(ctx context.Context, clientID int64, accountID string, regions string) (*cloudhealth.CostHistoryReport4Dim, error) {
	path := "/olap_reports/usage/instance"
	params := make(map[string][]string)
	params["client_api_id"] = []string{strconv.FormatInt(clientID, 10)}
	params["interval"] = []string{"hourly"}
	params["measures[]"] = []string{"usage_quantity"}
	params["dimensions[]"] = []string{"AWS-Regions", "EC2-Instance-Types", "EC2-Operating-Systems", "time"}
	params["filters[]"] = []string{"AWS-Coverage-Type:select:OnDemand", "AWS-Tenancy:select:default", getSelectedOperatingSystems(), getExcludedFamilies(), fmt.Sprintf("AWS-Account:select:%s", accountID)}

	if regions != "" {
		params["filters[]"] = append(params["filters[]"], regions)
	}

	return cloudhealth.Client.GetCostHistoryReport4Dim(path, params)
}

// getSupportedRegions There is a baseline of regions we support via Flexsave
// with original list containing only 7 regions, and later being extended by
// another 8. We also have the capability to override at a MPA level which regions
// we want to support as coverage might be provided by i.e. Savings Plans.
func getSupportedRegions(mpa *domain.MasterPayerAccount) string {
	mpaRegions := mpa.GetMasterPayerAccountRegions()

	if domain.RegionsArrayContainsAllValue(mpaRegions) {
		return ""
	}

	return "AWS-Regions:select:" + strings.Join((mpaRegions)[:], ",")
}

func getSelectedOperatingSystems() string {
	return "EC2-Operating-Systems:select:Linux/UNIX,Windows,Windows/SQL.Std,Windows/SQL.Ent,Windows/SQL.Web,Linux with SQL Std,Linux with SQL Web,Linux with SQL Ent"
}

// getExcludedFamilies We only support instance families that are covered by 1 year
// convertible RIs - none of the deprecated family types are supported.
func getExcludedFamilies() string {
	return "EC2-Instance-Type-Family:reject:m1,m2,m3,c1,c3,i2,cr1,r3,hs1,g2,t1"
}
